// Copyright 2022 Keyber Inc. All rights reserved.
// Use of this source code is governed by a MIT license that can be
// found in the LICENSE file.

import 'dart:convert';

import 'package:logger/logger.dart';

final logger = Logger(
  printer: _PrettyPrinter(),
  output: _ConsoleOutput(),
);

class _PrettyPrinter extends LogPrinter {
  _PrettyPrinter({
    this.colors = true,
    this.printCaller = true,
    this.printEmojis = true,
    this.printLevels = true,
    this.printTime = true,
  });

  /// 出力するログを色づけするかどうか
  final bool colors;

  /// ログの出力場所を出力するかどうか
  final bool printCaller;

  /// 絵文字を出力するかどうか
  final bool printEmojis;

  /// ログレベルを出力するかどうか
  final bool printLevels;

  /// 時刻を出力するかどうか
  final bool printTime;

  /// ログレベル毎のカラー
  static final _levelColors = {
    Level.verbose: AnsiColor.fg(AnsiColor.grey(0.5)),
    Level.debug: AnsiColor.none(),
    Level.info: AnsiColor.fg(12),
    Level.warning: AnsiColor.fg(208),
    Level.error: AnsiColor.fg(196),
    Level.wtf: AnsiColor.fg(199),
  };

  /// ログレベル毎の絵文字
  static final _levelEmojis = {
    Level.verbose: '🐱',
    Level.debug: '🐛',
    Level.info: '💡',
    Level.warning: '⚠️',
    Level.error: '⛔',
    Level.wtf: '👾',
  };

  /// ログレベル毎の文字列
  static final _levelLabels = {
    Level.verbose: '[VERBOSE]',
    Level.debug: '[DEBUG]  ',
    Level.info: '[INFO]   ',
    Level.warning: '[WARNING]',
    Level.error: '[ERROR]  ',
    Level.wtf: '[WTF]    ',
  };

  /// Matches a stacktrace line as generated on Android/iOS devices.
  /// For example:
  /// #1      Logger.log (package:logger/src/logger.dart:115:29)
  static final _deviceStackTraceRegex =
      RegExp(r'#[0-9]+[\s]+(.+) \(([^\s]+)\)');

  /// Matches a stacktrace line as generated by Flutter web.
  /// For example:
  /// packages/logger/src/printers/pretty_printer.dart 91:37
  static final _webStackTraceRegex =
      RegExp(r'^((packages|dart-sdk)\/[^\s]+\/)');

  /// Matches a stacktrace line as generated by browser Dart.
  /// For example:
  /// dart:sdk_internal
  /// package:logger/src/logger.dart
  static final _browserStackTraceRegex =
      RegExp(r'^(?:package:)?(dart:[^\s]+|[^\s]+)');

  @override
  List<String> log(LogEvent event) {
    // event.error と event.stackTrace は無視する
    return _formatAndPrint(
      event.level,
      _stringifyMessage(event.message),
      printTime ? _getTime() : null,
      printCaller ? _formatSingleStackTrace(StackTrace.current) : null,
    );
  }

  String? _formatSingleStackTrace(StackTrace? stackTrace) {
    final lines = stackTrace.toString().split('\n');
    for (final line in lines) {
      if (_discardDeviceStacktraceLine(line) ||
          _discardWebStacktraceLine(line) ||
          _discardBrowserStacktraceLine(line) ||
          line.isEmpty) {
        continue;
      }
      return line
          .replaceFirst(RegExp(r'#\d+\s+'), '')
          .replaceFirst(RegExp(r'package:[a-z0-9_]+\/'), '/');
    }
    return null;
  }

  bool _discardDeviceStacktraceLine(String line) {
    final match = _deviceStackTraceRegex.matchAsPrefix(line);
    if (match == null) {
      return false;
    }
    return match.group(1)!.startsWith('_PrettyPrinter') ||
        match.group(2)!.startsWith('package:logger');
  }

  bool _discardWebStacktraceLine(String line) {
    final match = _webStackTraceRegex.matchAsPrefix(line);
    if (match == null) {
      return false;
    }
    return match.group(1)!.startsWith('packages/logger') ||
        match.group(1)!.startsWith('dart-sdk/lib');
  }

  bool _discardBrowserStacktraceLine(String line) {
    final match = _browserStackTraceRegex.matchAsPrefix(line);
    if (match == null) {
      return false;
    }
    return match.group(1)!.startsWith('package:logger') ||
        match.group(1)!.startsWith('dart:');
  }

  String _getTime() {
    String _threeDigits(int n) {
      if (n >= 100) {
        return '$n';
      }
      if (n >= 10) {
        return '0$n';
      }
      return '00$n';
    }

    String _twoDigits(int n) {
      if (n >= 10) {
        return '$n';
      }
      return '0$n';
    }

    final now = DateTime.now();
    final h = _twoDigits(now.hour);
    final min = _twoDigits(now.minute);
    final sec = _twoDigits(now.second);
    final ms = _threeDigits(now.millisecond);
    return '$h:$min:$sec.$ms';
  }

  String _stringifyMessage(dynamic message) {
    final dynamic finalMessage =
        message is dynamic Function() ? message() : message;
    if (finalMessage is Map || finalMessage is Iterable) {
      final encoder = JsonEncoder.withIndent(
        '  ',
        (dynamic object) => object.toString(),
      );
      return encoder.convert(finalMessage);
    } else {
      return finalMessage.toString();
    }
  }

  AnsiColor _getLevelColor(Level level) {
    if (colors) {
      return _levelColors[level]!;
    } else {
      return AnsiColor.none();
    }
  }

  List<String> _formatAndPrint(
    Level level,
    String message,
    String? time,
    String? stacktrace,
  ) {
    final buffer = <String>[];
    final color = _getLevelColor(level);

    if (printEmojis) {
      buffer.add(color(_levelEmojis[level]!));
    }
    if (printLevels) {
      buffer.add(color(_levelLabels[level]!));
    }
    if (time != null) {
      buffer.add(color(time));
    }
    if (stacktrace != null) {
      buffer.add(color(stacktrace));
    }
    return ['${buffer.join(' ')}: ${color(message)}'];
  }
}

/// 致命的なエラーが起きたときはAssertionで処理を止める
class _ConsoleOutput extends ConsoleOutput {
  @override
  void output(OutputEvent event) {
    super.output(event);
    if (event.level.index >= Level.error.index) {
      // 致命的なエラーが発生したのでAssertionで止めるとStackTraceも表示される
      throw AssertionError('Stopped by logger');
    }
  }
}
